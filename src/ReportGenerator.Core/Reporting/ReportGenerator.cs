using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Palmmedia.ReportGenerator.Core.Common;
using Palmmedia.ReportGenerator.Core.Logging;
using Palmmedia.ReportGenerator.Core.Parser;
using Palmmedia.ReportGenerator.Core.Parser.Analysis;
using Palmmedia.ReportGenerator.Core.Properties;

namespace Palmmedia.ReportGenerator.Core.Reporting
{
    /// <summary>
    /// Converts a coverage report generated by OpenCoverand other tools into a readable report.
    /// </summary>
    internal class ReportGenerator
    {
        /// <summary>
        /// The Logger.
        /// </summary>
        private static readonly ILogger Logger = LoggerFactory.GetLogger(typeof(ReportGenerator));

        /// <summary>
        /// The parser to use.
        /// </summary>
        private readonly ParserResult parserResult;

        /// <summary>
        /// The renderers.
        /// </summary>
        private readonly IEnumerable<IReportBuilder> renderers;

        /// <summary>
        /// The assembly filter.
        /// </summary>
        private readonly IFilter assemblyFilter;

        /// <summary>
        /// The class filter.
        /// </summary>
        private readonly IFilter classFilter;

        /// <summary>
        /// The file filter.
        /// </summary>
        private readonly IFilter fileFilter;

        /// <summary>
        /// Initializes a new instance of the <see cref="ReportGenerator" /> class.
        /// </summary>
        /// <param name="parserResult">The parser result to use.</param>
        /// <param name="assemblyFilter">The assembly filter.</param>
        /// <param name="classFilter">The class filter.</param>
        /// <param name="fileFilter">The file filter.</param>
        /// <param name="renderers">The renderers.</param>
        internal ReportGenerator(ParserResult parserResult, IFilter assemblyFilter, IFilter classFilter, IFilter fileFilter, IEnumerable<IReportBuilder> renderers)
        {
            this.parserResult = parserResult ?? throw new ArgumentNullException(nameof(parserResult));
            this.assemblyFilter = assemblyFilter ?? throw new ArgumentNullException(nameof(assemblyFilter));
            this.classFilter = classFilter ?? throw new ArgumentNullException(nameof(classFilter));
            this.fileFilter = fileFilter ?? throw new ArgumentNullException(nameof(fileFilter));
            this.renderers = renderers ?? throw new ArgumentNullException(nameof(renderers));
        }

        /// <summary>
        /// Starts the generation of the report.
        /// </summary>
        /// <param name="addHistoricCoverage">if set to <c>true</c> historic coverage information is added to classes.</param>
        /// <param name="overallHistoricCoverages">All historic coverage elements.</param>
        /// <param name="executionTime">The execution time.</param>
        /// <param name="tag">The custom tag (e.g. build number).</param>
        /// <returns>The filters assemblies.</returns>
        internal IEnumerable<Assembly> CreateReport(bool addHistoricCoverage, List<HistoricCoverage> overallHistoricCoverages, DateTime executionTime, string tag)
        {
            var filteredAssemblies = this.parserResult.Assemblies
                .Where(a => this.assemblyFilter.IsElementIncludedInReport(a.Name))
                .Select(a =>
                {
                    var newAssembly = new Assembly(a.Name);
                    foreach (var @class in a.Classes)
                    {
                        if (classFilter.IsElementIncludedInReport(@class.Name))
                        {
                            // If all files are removed by filters, then the whole class gets removed/not added
                            bool hasFiles = @class.Files.Any();

                            foreach (var file in @class.Files.Where(f => !this.fileFilter.IsElementIncludedInReport(f.Path)))
                            {
                                @class.RemoveFile(file);
                            }

                            if (!hasFiles || @class.Files.Any())
                            {
                                newAssembly.AddClass(@class);
                            }
                        }
                    }

                    return newAssembly;
                })
                .ToArray();

            int numberOfClasses = filteredAssemblies.Sum(a => a.Classes.Count());

            Logger.InfoFormat(Resources.AnalyzingClasses, numberOfClasses);

            int counter = 0;

            int degreeOfParallelism = this.renderers.All(r => r.SupportsParallelClassReportExecution) ? Environment.ProcessorCount : 1;

            foreach (var assembly in filteredAssemblies)
            {
                Parallel.ForEach(
                        assembly.Classes,
                        new ParallelOptions() { MaxDegreeOfParallelism = degreeOfParallelism },
                        @class =>
                        {
                            Interlocked.Increment(ref counter);

                            Logger.DebugFormat(
                                " " + Resources.CreatingReport,
                                counter,
                                numberOfClasses,
                                @class.Assembly.ShortName,
                                @class.Name);

                            var fileAnalyses = @class.Files.Select(f => f.AnalyzeFile()).ToArray();

                            if (addHistoricCoverage)
                            {
                                var historicCoverage = new HistoricCoverage(@class, executionTime, tag);
                                @class.AddHistoricCoverage(historicCoverage);
                                overallHistoricCoverages.Add(historicCoverage);
                            }

                            Parallel.ForEach(
                                this.renderers,
                                renderer =>
                                {
                                    try
                                    {
                                        renderer.CreateClassReport(@class, fileAnalyses);
                                    }
                                    catch (Exception ex)
                                    {
                                        Logger.ErrorFormat(
                                            "  " + Resources.ErrorDuringRenderingClassReport,
                                            @class.Name,
                                            renderer.ReportType,
                                            ex.GetExceptionMessageForDisplay());
                                    }
                                });
                        });
            }

            Logger.Debug(" " + Resources.CreatingSummary);
            SummaryResult summaryResult = new SummaryResult(filteredAssemblies, this.parserResult.ParserName, this.parserResult.SupportsBranchCoverage);

            foreach (var renderer in this.renderers)
            {
                try
                {
                    renderer.CreateSummaryReport(summaryResult);
                }
                catch (Exception ex)
                {
                    Logger.ErrorFormat(
                        "  " + Resources.ErrorDuringRenderingSummaryReport,
                        renderer.ReportType,
                        ex.GetExceptionMessageForDisplay());
                }
            }

            return filteredAssemblies;
        }
    }
}